class DXRando extends DXRInfo transient;

var transient #var(PlayerPawn) Player;
var transient FlagBase flagbase;
var transient DXRFlags flags;
var transient DataStorage ds;
var transient DXRTelemetry telemetry;
var transient DeusExLevelInfo dxInfo;
var transient string localURL;

var int seed, tseed;

var transient private int CrcTable[256]; // for string hashing to do more stable seeding

var DXRando dxr;// singleton reference in default
var transient DXRBase modules[48];
var transient int num_modules;

var config string modules_to_load[47];// 1 less than the modules array, because we always load the DXRFlags module
var config int config_version;
var config int rando_beaten;

var transient bool runPostFirstEntry;
var transient bool bTickEnabled;// bTickEnabled is just for DXRandoTests to inspect
var transient bool bLoginReady;

#ifdef revision
var transient bool RevisionMaps;
#endif

replication
{
    reliable if( Role==ROLE_Authority )
        modules, num_modules, runPostFirstEntry, bTickEnabled, localURL, dxInfo, telemetry, flags, flagbase, CrcTable, seed;
}

simulated event PostNetBeginPlay()
{
    Super.PostNetBeginPlay();
    Player = #var(PlayerPawn)(GetPlayerPawn());
    l(Self$".PostNetBeginPlay() "$Player);
    SetTimer(0.2, true);
}

simulated event Timer()
{
    local int i;
    if( bTickEnabled == true ) return;

    if( bLoginReady ) {
        PlayerLogin(Player);
        SetTimer(0, false);
    }

    if( ! CheckLogin(Player) )
        return;

    bLoginReady = true;
}

function SetdxInfo(DeusExLevelInfo i)
{
    dxInfo = i;
    if(i == None) {
        warning("SetdxInfo got None, LevelInfo: "$ Level @ Level.Title);
        return;
    }
    localURL = Caps(dxInfo.mapName);
    l("SetdxInfo got localURL: " $ localURL $ ", mapname: " $ i.MissionLocation);

    dxr = self;
    default.dxr = self;// singleton reference

    // undo the damage that DXRBacktracking has done to prevent saves from being deleted
    // must do this before the mission script is loaded, so we can't wait for finding the player and loading modules
    class'DXRBacktracking'.static.LevelInit(Self);

#ifdef playersonly
    Level.bPlayersOnly = true;
#elseif supercut
    Level.bPlayersOnly = false;
#endif
    CrcInit();
    ClearModules();
    LoadFlagsModule();

    Enable('Tick');
    bTickEnabled = true;
}

function DXRInit()
{
    if(!#defined(hx))
        l("DXRInit has localURL == " $ localURL $ ", flagbase == "$flagbase);
    if( flagbase != None ) return;

    Player = #var(PlayerPawn)(GetPlayerPawn());
    if( Player == None )
        foreach AllActors(class'#var(PlayerPawn)', Player)
            break;
    if(Player == None)
        return;

#ifdef supercut
    Player.bCheatsEnabled = true;
    Player.Invisible(true);
    Player.GotoState('Paralyzed');
#endif

#ifdef revision
    RevisionMaps = class'DXRMapVariants'.static.IsRevisionMaps(Player,true);
#endif

    flagbase = Player.FlagBase;
#ifdef hx
    flagbase = HXGameInfo(Level.Game).Steve.FlagBase;
#endif
    if( flagbase == None ) {
        warn("DXRInit() didn't find flagbase?");
        return;
    }
    l("found flagbase: "$flagbase$", Player: "$Player);

    CheckConfig();
    flags.InitCoordsMult();// for some reason flags is loaded too early and doesn't have the new map url
    flags.LoadFlags();
#ifdef supercut
    flags.RollSeed();
#endif
    LoadModules();
    RandoEnter();
}

simulated event PreTravel()
{
    local int i;
    for(i=0; i<num_modules; i++) {
        modules[i].PreTravel();
        modules[i] = None;
    }
    num_modules = 0;
    default.dxr = None;// clear the singleton reference
    flagbase = None;
    Disable('Tick');
    bTickEnabled = false;
    SetTimer(0, false);
}

simulated event Destroyed()
{
    default.dxr = None;// clear the singleton reference
}

function CheckConfig()
{
    local int i;

    if( VersionOlderThan(config_version, 2,6,0,1) ) {
        rando_beaten = 0;
        player.bAskedToTrain = false;
        player.SaveConfig();
    }
    if( VersionOlderThan(config_version, 2,6,2,1) ) {
        for(i=0; i < ArrayCount(modules_to_load); i++) {
            modules_to_load[i] = "";
        }

        if(#defined(vanilla))
            vanilla_modules();
        else if(#defined(hx))
            hx_modules();
        else if(#defined(gmdx))
            gmdx_modules();
        else if(#defined(revision))
            revision_modules();
        else if(#defined(vmd))
            vmd_modules();
        else {
            warning("unknown mod, using default set of modules!");
            hx_modules();
        }
    }
    Super.CheckConfig();
}

function vanilla_modules()
{
    local int i;
    modules_to_load[i++] = "DXRTelemetry";
    modules_to_load[i++] = "DXRMissions";
    modules_to_load[i++] = "DXRSwapItems";
    //modules_to_load[i++] = "DXRAddItems";
    modules_to_load[i++] = "DXRFixup";
    modules_to_load[i++] = "DXRBrightness";
    modules_to_load[i++] = "DXRBacktracking";
    modules_to_load[i++] = "DXRKeys";
    modules_to_load[i++] = "DXRDoors";
    modules_to_load[i++] = "DXRSkills";
    modules_to_load[i++] = "DXRPasswords";
    modules_to_load[i++] = "DXRAugmentations";
    modules_to_load[i++] = "DXRReduceItems";
    modules_to_load[i++] = "DXRNames";
    modules_to_load[i++] = "DXRMemes";
    modules_to_load[i++] = "DXREnemies";
    modules_to_load[i++] = "DXREntranceRando";
    modules_to_load[i++] = "DXRAutosave";
    modules_to_load[i++] = "DXRHordeMode";
    //modules_to_load[i++] = "DXRKillBobPage";
    modules_to_load[i++] = "DXREnemyRespawn";
    modules_to_load[i++] = "DXRLoadouts";
    modules_to_load[i++] = "DXRWeapons";
    modules_to_load[i++] = "DXRCrowdControl";
    modules_to_load[i++] = "DXRMachines";
    modules_to_load[i++] = "DXRStats";
    modules_to_load[i++] = "DXRNPCs";
    modules_to_load[i++] = "DXRFashion";
    modules_to_load[i++] = "DXRHints";
    modules_to_load[i++] = "DXRStartMap";
    modules_to_load[i++] = "DXREvents";
    //modules_to_load[i++] = "DXRMapInfo";
    modules_to_load[i++] = "DXRMusic";
    modules_to_load[i++] = "DXRMusicPlayer";
    modules_to_load[i++] = "DXRPlayerStats";
    modules_to_load[i++] = "DXRMapVariants";
    modules_to_load[i++] = "DXRWeaponMods";
    modules_to_load[i++] = "DXRGrenades";
    modules_to_load[i++] = "DXRCameraModes";
}

function hx_modules()
{
    local int i;
    modules_to_load[i++] = "DXRTelemetry";
    modules_to_load[i++] = "DXRMissions";
    modules_to_load[i++] = "DXRSwapItems";
    modules_to_load[i++] = "DXRFixup";
    modules_to_load[i++] = "DXRBrightness";
    modules_to_load[i++] = "DXRKeys";
    modules_to_load[i++] = "DXRDoors";
    modules_to_load[i++] = "DXRSkills";
    modules_to_load[i++] = "DXRPasswords";
    modules_to_load[i++] = "DXRAugmentations";
    modules_to_load[i++] = "DXRReduceItems";
    modules_to_load[i++] = "DXRNames";
    modules_to_load[i++] = "DXRMemes";
    modules_to_load[i++] = "DXREnemies";
    modules_to_load[i++] = "DXRHordeMode";
    modules_to_load[i++] = "DXREnemyRespawn";
    modules_to_load[i++] = "DXRLoadouts";
    modules_to_load[i++] = "DXRWeapons";
    modules_to_load[i++] = "DXRCrowdControl";
    modules_to_load[i++] = "DXRMachines";
    modules_to_load[i++] = "DXRStats";
    modules_to_load[i++] = "DXRHints";
    modules_to_load[i++] = "DXRReplaceActors";
    modules_to_load[i++] = "DXRStartMap";
    modules_to_load[i++] = "DXREvents";
    modules_to_load[i++] = "DXRPlayerStats";
    modules_to_load[i++] = "DXRMapVariants";
    modules_to_load[i++] = "DXRWeaponMods";
    modules_to_load[i++] = "DXRGrenades";
}

function gmdx_modules()
{
    local int i;
    modules_to_load[i++] = "DXRTelemetry";
    modules_to_load[i++] = "DXRMissions";
    modules_to_load[i++] = "DXRSwapItems";
    modules_to_load[i++] = "DXRFixup";
    modules_to_load[i++] = "DXRBrightness";
    modules_to_load[i++] = "DXRKeys";
    modules_to_load[i++] = "DXRDoors";
    modules_to_load[i++] = "DXRSkills";
    modules_to_load[i++] = "DXRPasswords";
    modules_to_load[i++] = "DXRAugmentations";
    modules_to_load[i++] = "DXRReduceItems";
    modules_to_load[i++] = "DXRNames";
    modules_to_load[i++] = "DXRMemes";
    modules_to_load[i++] = "DXREnemies";
    modules_to_load[i++] = "DXRHordeMode";
    modules_to_load[i++] = "DXREnemyRespawn";
    modules_to_load[i++] = "DXRLoadouts";
    modules_to_load[i++] = "DXRWeapons";
    modules_to_load[i++] = "DXRCrowdControl";
    modules_to_load[i++] = "DXRMachines";
    modules_to_load[i++] = "DXRStats";
    modules_to_load[i++] = "DXRHints";
    modules_to_load[i++] = "DXRReplaceActors";
    modules_to_load[i++] = "DXRNPCs";
    modules_to_load[i++] = "DXRFashion";
    modules_to_load[i++] = "DXRStartMap";
    modules_to_load[i++] = "DXREvents";
    modules_to_load[i++] = "DXRMusic";
    modules_to_load[i++] = "DXRMusicPlayer";
    modules_to_load[i++] = "DXRPlayerStats";
    modules_to_load[i++] = "DXRMapVariants";
    modules_to_load[i++] = "DXRWeaponMods";
    modules_to_load[i++] = "DXRGrenades";
    modules_to_load[i++] = "DXRCameraModes";
}

function revision_modules()
{
    gmdx_modules();
}

function vmd_modules()
{
    local int i;
    modules_to_load[i++] = "DXRTelemetry";
    modules_to_load[i++] = "DXRMissions";
    modules_to_load[i++] = "DXRSwapItems";
    modules_to_load[i++] = "DXRFixup";
    modules_to_load[i++] = "DXRBrightness";
    modules_to_load[i++] = "DXRKeys";
    modules_to_load[i++] = "DXRDoors";
    modules_to_load[i++] = "DXRSkills";
    modules_to_load[i++] = "DXRPasswords";
    modules_to_load[i++] = "DXRAugmentations";
    modules_to_load[i++] = "DXRReduceItems";
    modules_to_load[i++] = "DXRNames";
    modules_to_load[i++] = "DXRMemes";
    modules_to_load[i++] = "DXREnemies";
    modules_to_load[i++] = "DXRHordeMode";
    modules_to_load[i++] = "DXREnemyRespawn";
    modules_to_load[i++] = "DXRLoadouts";
    modules_to_load[i++] = "DXRWeapons";
    modules_to_load[i++] = "DXRCrowdControl";
    modules_to_load[i++] = "DXRMachines";
    modules_to_load[i++] = "DXRStats";
    modules_to_load[i++] = "DXRHints";
    modules_to_load[i++] = "DXRReplaceActors";
    modules_to_load[i++] = "DXRNPCs";
    modules_to_load[i++] = "DXRStartMap";
    modules_to_load[i++] = "DXREvents";
    modules_to_load[i++] = "DXRMusic";
    modules_to_load[i++] = "DXRMusicPlayer";
    modules_to_load[i++] = "DXRPlayerStats";
    modules_to_load[i++] = "DXRMapVariants";
    modules_to_load[i++] = "DXRWeaponMods";
    modules_to_load[i++] = "DXRGrenades";
    modules_to_load[i++] = "DXRCameraModes";
}

function DXRFlags LoadFlagsModule()
{
    // always force a new spawn, DXRFlags is transient anyways, and then new game menu calls this function
    flags = DXRFlags(LoadModule(class'DXRFlags', true));
    return flags;
}

function DXRBase LoadModule(class<DXRBase> moduleclass, optional bool forcenew)
{
    local DXRBase m;
    moduleclass = moduleclass.static.GetModuleToLoad(self, moduleclass);
    l("loading module "$moduleclass);

    if(!forcenew) {
        m = FindModule(moduleclass, true);
        if( m != None ) {
            info("found already loaded module "$m);
            if(m.dxr != Self) m.Init(Self);
            return m;
        }
    }

    m = Spawn(moduleclass, None);
    if ( m == None ) {
        err("failed to load module "$moduleclass);
        return None;
    }
    modules[num_modules] = m;
    num_modules++;
    m.Init(Self);
    l("finished loading module "$m);
    return m;
}

function DXRBase LoadModuleByString(string classstring)
{
    local class<Actor> c;
    if( InStr(classstring, ".") == -1 ) {
        classstring = "#var(package)." $ classstring;
    }
    c = flags.GetClassFromString(classstring, class'DXRBase');
    return LoadModule( class<DXRBase>(c) );
}

function LoadModules()
{
    local int i;

    for( i=0; i < ArrayCount( modules_to_load ); i++ ) {
        if( modules_to_load[i] == "" ) continue;
        LoadModuleByString(modules_to_load[i]);
    }

    telemetry = DXRTelemetry(FindModule(class'DXRTelemetry'));
}

simulated final function DXRBase FindModule(class<DXRBase> moduleclass, optional bool bSilent)
{
    local DXRBase m;
    local int i;
    for(i=0; i<num_modules; i++)
        if( modules[i] != None )
            if( ClassIsChildOf(modules[i].Class, moduleclass) )
                return modules[i];

    foreach AllActors(class'DXRBase', m)
    {
        if( ClassIsChildOf(m.Class, moduleclass) ) {
            if(!bSilent)
                l("FindModule("$moduleclass$") found "$m);
            m.Init(Self);
            modules[num_modules] = m;
            num_modules++;
            return m;
        }
    }

    if(!bSilent)
        l("didn't find module "$moduleclass);
    return None;
}

function ClearModules()
{
    num_modules=0;
    flags=None;
}

simulated event Tick(float deltaTime)
{
    if( Role < ROLE_Authority ) {
        Disable('Tick');
        return;
    }
    DXRTick(deltaTime);
}

function DXRTick(float deltaTime)
{
    local #var(PlayerPawn) pawn;
    local int i;
    SetTimer(0, false);
    if( dxInfo == None )
    {
        //waiting...
        //l("DXRTick dxInfo == None");
        return;
    }
    else if( flagbase == None )
    {
        DXRInit();
    }
    else if(runPostFirstEntry)
    {
        SetSeed( Crc(seed $ localURL $ " PostFirstEntry") );
        for(i=0; i<num_modules; i++) {
            modules[i].PostFirstEntry();
        }
        info("done randomizing "$localURL$" PostFirstEntry using seed " $ seed $ ", deltaTime: " $ deltaTime);
        runPostFirstEntry = false;
    }
    else
    {
        RunTests();

        SetSeed( Crc(seed $ localURL $ " PostAnyEntry") );
        for(i=0; i<num_modules; i++) {
            modules[i].PostAnyEntry();
        }

        Disable('Tick');
        bTickEnabled = false;
    }
}

function RandoEnter()
{
    local #var(PlayerPawn) pawn;
    local int i;
    local bool firstTime;
    local name flagName;
    local bool IsTravel;
    local string map;

    if( flagbase == None ) {
        err("RandoEnter() flagbase == None");
        return;
    }

    IsTravel = flagbase.GetBool('PlayerTraveling');

    map = localURL;
    map = class'DXRMapVariants'.static.GetDirtyMapName(map, flags.coords_mult);
    flagName = flagbase.StringToName("M"$StripMapName(map)$"_Randomized");
    if (!flagbase.GetBool(flagName))
    {
        firstTime = True;
        flagbase.SetBool(flagName, True,, dxInfo.missionNumber+1);
    }

    info("RandoEnter() firstTime: "$firstTime$", IsTravel: "$IsTravel$", seed: "$seed @ localURL @ map @ GetURLMap());

    SetSeed( Crc(seed $ localURL @ firstTime) );
    if ( firstTime == true )
    {
        //if( !IsTravel ) warning(localURL$": loaded save but FirstEntry? firstTime: "$firstTime$", IsTravel: "$IsTravel);

        info("randomizing "$localURL$" using seed " $ seed);

        for(i=0; i<num_modules; i++) {
            modules[i].PreFirstEntry();
        }

        for(i=0; i<num_modules; i++) {
            modules[i].FirstEntry();
        }

        runPostFirstEntry = true;
        info("done randomizing "$localURL$" using seed " $ seed);
    }
    else
    {
        for(i=0; i<num_modules; i++) {
            modules[i].ReEntry(IsTravel);
        }
    }

    SetSeed( Crc(seed $ localURL $ " AnyEntry") );
    for(i=0; i<num_modules; i++) {
        modules[i].AnyEntry();
    }

    SetSeed( Crc(seed $ localURL $ " PlayerLogin") );
    foreach AllActors(class'#var(PlayerPawn)', pawn) {
        PlayerLogin(pawn);
    }
}

simulated function bool CheckLogin(#var(PlayerPawn) p)
{
    local int i;

    err("CheckLogin("$p$"), bTickEnabled: "$bTickEnabled$", flagbase: "$flagbase$", num_modules: "$num_modules$", flags: "$flags);
    if( bTickEnabled == true ) return false;

    for(i=0; i<num_modules; i++) {
        if( modules[i] == None )
            return false;
        if( modules[i].dxr != Self )
            return false;
        if( ! modules[i].CheckLogin(p) )
            return false;
    }
    return true;
}

simulated function PlayerLogin(#var(PlayerPawn) p)
{
    local int i;
    local PlayerDataItem data;

    if( flags == None || !flags.flags_loaded ) {
        info("PlayerLogin("$p$") flags: "$flags$", flags.flags_loaded: "$flags.flags_loaded);
        return;
    }

    data = class'PlayerDataItem'.static.GiveItem(p);
    info("PlayerLogin("$p$") do it, p.PlayerDataItem: " $ data $", data.local_inited: "$data.local_inited$", mission: "$dxInfo.missionNumber);

#ifdef singleplayer
    if ( flags.stored_version != 0 && flags.stored_version < VersionNumber() ) {
        info("upgrading "$data$" from "$data.version$" to "$VersionNumber());
        data.version = VersionNumber();
    }
#endif

    if( !data.local_inited && dxInfo.missionNumber > 0 && dxInfo.missionNumber < 98 )
    {
        for(i=0; i<num_modules; i++) {
            modules[i].PlayerLogin(p);
        }
        data.local_inited = true;
    }
    for(i=0; i<num_modules; i++) {
        modules[i].PlayerAnyEntry(p);
    }

    data.version = VersionNumber();
}

simulated function PlayerRespawn(#var(PlayerPawn) p)
{
    local int i;
    for(i=0; i<num_modules; i++) {
        modules[i].PlayerRespawn(p);
    }
}

simulated final function int SetSeed(int s)
{
    local int oldseed;
    oldseed = tseed;
    //log("SetSeed old seed == "$newseed$", new seed == "$s);
    tseed = s;
    return oldseed;
}

const gen1 = 1073741821;// half of gen2, rounded down
const gen2 = 2147483643;
simulated final function int rng(int max)
{
    tseed = gen1 * tseed * 5 + gen2 + (tseed/5) * 3;
    // in unrealscript >>> is right shift and filling the left with 0s, >> shifts but keeps the sign
    // this means we don't need abs, which is a float function anyways
    return imod((tseed >>> 8), max);
}

simulated final function int rngraw()
{
    tseed = gen1 * tseed * 5 + gen2 + (tseed/5) * 3;
    // in unrealscript >>> is right shift and filling the left with 0s, >> shifts but keeps the sign
    // this means we don't need abs, which is a float function anyways
    return (tseed >>> 8);
}


// ============================================================================
// CrcInit https://web.archive.org/web/20181105143221/http://unrealtexture.com/Unreal/Downloads/3DEditing/UnrealEd/Tutorials/unrealwiki-offline/crc32.html
//
// Initializes CrcTable and prepares it for use with Crc.
// ============================================================================

simulated final function CrcInit() {

    const CrcPolynomial = 0xedb88320;

    local int CrcValue;
    local int IndexBit;
    local int IndexEntry;

    for (IndexEntry = 0; IndexEntry < 256; IndexEntry++) {
        CrcValue = IndexEntry;

        for (IndexBit = 8; IndexBit > 0; IndexBit--)
        {
            if ((CrcValue & 1) != 0)
                CrcValue = (CrcValue >>> 1) ^ CrcPolynomial;
            else
                CrcValue = CrcValue >>> 1;
        }

        CrcTable[IndexEntry] = CrcValue;
    }
}


// ============================================================================
// Crc
//
// Calculates and returns a checksum of the given string. Call CrcInit before.
// ============================================================================

simulated final function int Crc(coerce string Text) {

    local int CrcValue;
    local int IndexChar;

    //if(CrcTable[1] == 0)
        //err("CrcTable uninitialized?");

    CrcValue = 0xffffffff;

    for (IndexChar = 0; IndexChar < Len(Text); IndexChar++)
        CrcValue = (CrcValue >>> 8) ^ CrcTable[Asc(Mid(Text, IndexChar, 1)) ^ (CrcValue & 0xff)];

    return CrcValue;
}

simulated function DXRando GetDXR()
{
    return Self;
}

function RunTests()
{
    local int i, failures;
    l("starting RunTests()");
    for(i=0; i<num_modules; i++) {
        modules[i].StartRunTests();
        if( modules[i].fails > 0 ) {
            failures++;
            Player.ShowHud(true);
            err( "ERROR: " $ modules[i] @ modules[i].fails $ " tests failed!" );
        }
        else
            l( modules[i] $ " passed tests!" );
    }

    if( failures == 0 ) {
        l( "all tests passed!" );
    } else {
        Player.ShowHud(true);
        err( "ERROR: " $ failures $ " modules failed tests!" );
    }
}

function ExtendedTests()
{
    local int i, failures;
    l("starting ExtendedTests()");
    for(i=0; i<num_modules; i++) {
        modules[i].StartExtendedTests();
        if( modules[i].fails > 0 ) {
            failures++;
            Player.ShowHud(true);
            err( "ERROR: " $ modules[i] @ modules[i].fails $ " tests failed!" );
        }
        else
            l( modules[i] $ " passed tests!" );
    }

    if( failures == 0 ) {
        l( "all extended tests passed!" );
    } else {
        Player.ShowHud(true);
        err( "ERROR: " $ failures $ " modules failed tests!" );
    }
}

defaultproperties
{
    NetPriority=0.1
}
